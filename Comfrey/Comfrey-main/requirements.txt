# Comfrey Framework Requirements
# Core dependencies for LLM output error detection and repair
# Implements low-overhead design principles from the paper

# Core Python libraries (built-in, no installation needed)
# - ast: Abstract Syntax Tree manipulation
# - dis: Python bytecode disassembler  
# - json: JSON parsing and generation
# - xml: XML processing
# - re: Regular expressions
# - logging: Logging functionality
# - typing: Type hints
# - enum: Enumeration support
# - unicodedata: Unicode character database

# External dependencies for core functionality
numpy>=1.21.0

# Two-stage similarity detection (Section 4.3.3 and 4.5.2)
scikit-learn>=1.3.0      # TF-IDF vectorization and cosine similarity
sentence-transformers>=2.2.0  # Sentence embeddings for 0.6B parameter model equivalent

# Professional static analysis tools
networkx>=3.2.1          # Graph analysis for call graph construction
pyan3>=1.2.0             # Python call graph generation
beniget>=0.4.1           # Precise def-use chain analysis

# NLP and text processing (Section 4.4.2 - Lexical features)
spacy>=3.4.0             # Advanced sentence analysis
pyenchant>=3.2.0         # Dictionary validation for language standards
nltk>=3.7                # N-gram frequency analysis

# Optional: Enhanced NLP model for spaCy
# Run: python -m spacy download en_core_web_sm

# Development and testing (optional)
pytest>=7.0.0
pytest-cov>=4.0.0
black>=22.0.0
flake8>=5.0.0

# Documentation (optional)
sphinx>=5.0.0
sphinx-rtd-theme>=1.0.0

# Installation instructions:
# 1. Install core dependencies: pip install -r requirements.txt
# 2. Install spaCy English model: python -m spacy download en_core_web_sm
# 3. For enchant on macOS: brew install enchant
# 4. For enchant on Ubuntu: sudo apt-get install libenchant-2-2
# 5. For enchant on Windows: conda install pyenchant

# Note: The framework uses lightweight models for low overhead design:
# - all-MiniLM-L6-v2 (~80MB) for sentence embeddings (equivalent to 0.6B parameter model)
# - TF-IDF for first-stage similarity detection
# - Rule-based techniques prioritized over computation-intensive methods 